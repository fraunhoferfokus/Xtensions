
== Extensions to Iterable

The `de.fhg.fokus.xtensions.iteration.IterableExtensions` class provides extension methods to 
`java.lang.Iterable`

Unfortunately the `java.lang.Iterable` interface does not provide a (default)
method for creating a `java.lang.Stream`. It does provide a method to obtain a 
`Spliterator` which can be used to create a stream, but this is rather unpleasant to use. +
The `IterableExtensions` class provides the `stream` extension method to easily create
a stream from an iterable. This method will first check if the given iterable is instance of
`java.util.Collection`, since this class does provide a default `stream` method,
otherwise it will construct a stream from the spliterator provided by the iterable.

Example:

[source,xtend]
----
import static extension de.fhg.fokus.xtensions.iteration.IterableExtensions.*
import java.util.OptionalDouble
//...
#["foo", null, "BAR", "bazzzz"]
	.filterNull
	.averageSize
	.ifPresent [
		println('''The average string lenght is «it»''')
	]

//...

private def OptionalDouble averageSize(Iterable<String> strings) {
	strings.stream.mapToInt[length].average // <1>
}
----
<1> In this line the extension method `stream` is called on the iterable `strings`.

Analogous to the `stream` method the `IterableExtensions` class also provides a `parallelStream` method.

It is also possible to map an iterable to a primitive iterable 
(see <<08_primitive_iterables#from-iterables,Primitve Iterables / From Iterables>>).


The JDK since Java 8 provides the class `java.util.stream.Collector` which can be used with streams
to perform a reduction operation over all elements in a stream. The class `java.util.stream.Collectors`
already provides constructor methods for a bunch of useful collectors. The `IterableExtensions` class
of this library provides a `collect` extension method directly for `Iterable` to easily reduce the elements
of the iterable.

Example:

[source,xtend]
----
import static java.util.stream.Collectors.*
import static extension de.fhg.fokus.xtensions.iteration.IterableExtensions.*
// ...
val Iterable<String> strings = #["fooooo", "baar", "baz"]
val summary = strings.collect(summarizingInt[length])
println("Average length: " + summary.average)
println("Max length: " + summary.max)
----


A fairly common task in Model-to-Model transformations is to find objects of one type that are not referenced by 
some other objects. This is usually done by navigation over all elements in a model, finding all elements of both
types and then finding the elements that are actually not referenced. This is typically done by traversing the 
complete model twice to find the elements of both types. This can be an expensive operation if the input model
is large. The solution is to traverse the model just once and group the elements according to their type.

This library provides a method allowing exactly this. The method `groupIntoListBy` and `groupIntoSetBy`
groups elements of an iterable by their type.

Example:

[source,xtend]
----
val foo = "foo"
val bar = "bar"
val baz = "baz"
val traverseMe = #[foo, #[bar], baz, #[foo], bar]
val groups = traverseMe.groupIntoSetBy(String, List)

val Set<String> strings = groups.get(String)
val Set<List> lists = groups.get(List)
val inNoList = strings
	.filter[str| 
		!lists.exists[it.contains(str)]
	].toList
println("Elements contained in no list: " + inNoList)
----


[TIP]
====
Related JavaDocs:

* https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/iteration/IterableExtensions.html[IterableExtensions]
====
