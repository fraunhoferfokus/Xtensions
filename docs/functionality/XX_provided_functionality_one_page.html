
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Provided Functionality (as Single Page) Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="../../CHANGES.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../SUMMARY.html">
            
                <a href="../../SUMMARY.html">
            
                    
                    Content
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../provided_functionality.html">
            
                <a href="../provided_functionality.html">
            
                    
                    Provided Functionality
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="01_optionals.html">
            
                <a href="01_optionals.html">
            
                    
                    Extensions to Optionals
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="02_ranges.html">
            
                <a href="02_ranges.html">
            
                    
                    Extensions to Ranges
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="03_pair.html">
            
                <a href="03_pair.html">
            
                    
                    Extensions to Pair
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="04_primitive_arrays.html">
            
                <a href="04_primitive_arrays.html">
            
                    
                    Extensions to Primitive Arrays
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="05_streams.html">
            
                <a href="05_streams.html">
            
                    
                    Extensions to Streams
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="06_iterable.html">
            
                <a href="06_iterable.html">
            
                    
                    Extensions to Iterable
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="07_iterator.html">
            
                <a href="07_iterator.html">
            
                    
                    Extensions to Iterator
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="08_primitive_iterables.html">
            
                <a href="08_primitive_iterables.html">
            
                    
                    Primitive Iterables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="09_primitive_iterators.html">
            
                <a href="09_primitive_iterators.html">
            
                    
                    Extensions to PrimitiveIterators
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="10_strings.html">
            
                <a href="10_strings.html">
            
                    
                    Extensions to Strings
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="11_duration.html">
            
                <a href="11_duration.html">
            
                    
                    Extensions to Duration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="12_functions.html">
            
                <a href="12_functions.html">
            
                    
                    Extensions to Functions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="13_completable_future.html">
            
                <a href="13_completable_future.html">
            
                    
                    Extensions to CompletableFuture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.14" data-path="14_async_computations.html">
            
                <a href="14_async_computations.html">
            
                    
                    Async Computations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.15" data-path="15_scheduling_util.html">
            
                <a href="15_scheduling_util.html">
            
                    
                    Scheduling Util
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.16" data-path="16_primitives.html">
            
                <a href="16_primitives.html">
            
                    
                    Primitives
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../development.html">
            
                <a href="../development.html">
            
                    
                    Development on Xtensions
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../CONTRIBUTING.html">
            
                <a href="../../CONTRIBUTING.html">
            
                    
                    Contributing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../CODE_OF_CONDUCT.html">
            
                <a href="../../CODE_OF_CONDUCT.html">
            
                    
                    Code of Conduct
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Appendix</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../../CHANGES.html">
            
                <a href="../../CHANGES.html">
            
                    
                    Changelog
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.2" data-path="XX_provided_functionality_one_page.html">
            
                <a href="XX_provided_functionality_one_page.html">
            
                    
                    Provided Functionality (as Single Page)
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Provided Functionality (as Single Page)</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="provided-functionality">Provided Functionality</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>If you want to know how to add the library to your project, have a look at the <a href="../README.adoc">Introduction</a>.</p>
</div>
<div class="paragraph">
<p>The sub-chapters of this chapter will provide a high level overview on how to use the different parts of this library.</p>
</div>
<div class="paragraph">
<p>When using the library in OSGi it is recommended to use package imports since the library may evolve
and split into multiple bundles in future releases.</p>
</div>
<div class="paragraph">
<p>The following chapters will give an overview over the most important extensions and types provided
by the library. It does not include all methods. Please have a look at the sources or the JavaDocs
to explore all available functionality.</p>
</div>
<div class="paragraph">
<p>Most of the given examples in the following sections and some more are defined in the following
test class:
<a href="https://github.com/fraunhoferfokus/Xtensions/blob/master/tests/de.fhg.fokus.xtensions.tests/src/de/fhg/fokus/xtensions/Showcase.xtend" target="_blank">Showcase.xtend</a></p>
</div>
<div class="paragraph">
<p>If you want to see the overview all chapters of the documentation, have a look at the <a href="../SUMMARY.adoc">Content</a> page.</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">Contents of this document:</div>
<ul class="sectlevel1">
<li><a href="#_extensions_to_optional">Extensions to Optional</a></li>
<li><a href="#_extensions_to_primitive_optionals">Extensions to Primitive Optionals</a></li>
<li><a href="#_extensions_to_integerrange">Extensions to IntegerRange</a></li>
<li><a href="#_extensions_to_pair">Extensions to Pair</a></li>
<li><a href="#_extensions_to_primitive_arrays">Extensions to Primitive Arrays</a></li>
<li><a href="#_extensions_to_streams">Extensions to Streams</a></li>
<li><a href="#_extensions_to_streams_of_strings">Extensions to Streams of Strings</a></li>
<li><a href="#_extensions_to_iterable">Extensions to Iterable</a></li>
<li><a href="#_extensions_to_iterator">Extensions to Iterator</a></li>
<li><a href="#_primitive_iterables">Primitive Iterables</a>
<ul class="sectlevel2">
<li><a href="#from-iterables">From Iterables</a></li>
<li><a href="#_from_arrays">From Arrays</a></li>
<li><a href="#_from_computations">From Computations</a></li>
<li><a href="#_from_xtend_ranges">From Xtend Ranges</a></li>
<li><a href="#_from_primitive_optionals">From Primitive Optionals</a></li>
</ul>
</li>
<li><a href="#_extensions_to_primitiveiterators">Extensions to PrimitiveIterators</a></li>
<li><a href="#_extensions_to_string">Extensions to String</a></li>
<li><a href="#_extensions_to_duration">Extensions to Duration</a></li>
<li><a href="#_extensions_to_functions">Extensions to Functions</a></li>
<li><a href="#_extensions_to_completablefuture">Extensions to CompletableFuture</a></li>
<li><a href="#_async_computations">Async Computations</a></li>
<li><a href="#_scheduling_util">Scheduling Util</a></li>
<li><a href="#_primitives">Primitives</a>
<ul class="sectlevel2">
<li><a href="#_boxing_primitives">Boxing Primitives</a></li>
<li><a href="#_testing_conditions_on_primitive_values">Testing Conditions on Primitive Values</a></li>
<li><a href="#_conversion_to_optionals">Conversion to Optionals</a></li>
<li><a href="#_default_values_for_code_null_code_boxes">Default Values for <code>null</code> Boxes</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_optional">Extensions to Optional</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The static factory Methods for creating <code>Optional</code> instances are not really meant to be used as
statically imported methods. They have no meaningful names to be used this way. They also differ from
the commonly used names <code>some</code>, <code>none</code> and <code>maybe</code> which are used in many other languages.<br>
The class <code>OptionalIntExtensions</code> provides static factory methods with these common names
which are implemented to be inlined to the factory methods used by the JDK.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.Optional
import static extension de.fhg.fokus.xtensions.optional.OptionalIntExtensions.*
// ...
val Optional&lt;String&gt; no = none
val Optional&lt;String&gt; yes = some(&quot;yesss!&quot;)
val Optional&lt;String&gt; dunno = maybe(possiblyNull())
// ...
private def String possiblyNull() {
	if(System.currentTimeMillis % 2 == 0) {
		&quot;I&apos;m in ur optional&quot;
	} else {
		null
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The optional class does not provide a <code>filter</code> method, that filters the optional based on the class
the wrapped object is instance of, as known e.g. from Xtend&#x2019;s filter methods on <code>Iterable</code>.
The <code>OptionalIntExtensions</code> adds such a method, providing an instance check of the wrapped value.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.Optional
import static extension de.fhg.fokus.xtensions.optional.OptionalIntExtensions.*
// ...
val Optional&lt;Object&gt; optObj = some(&quot;Hi there!&quot;)
val Optional&lt;String&gt; optStr = optObj.filter(String)
optStr.ifPresent [
	println(it.toUpperCase)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>When testing an <code>Optional</code> for a value or otherwise perform a different operation
the optional has to be used twice e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.Optional
// ...
val noVal = Optional.empty
if(noVal.isPresent) {
	val value = noVal.get
	println(&quot;Here is your value: &quot;+ value)
} else {
	println(&quot;Awww, no value&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can be error prone, since the optional (in the example <code>noVal</code>) has to be
used twice and a different optional may be used accidently. To not run into this
issue this library provides the <code>whenPresent</code> method which allows defining an
else branch on the returned object.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.Optional
import static extension de.fhg.fokus.xtensions.optional.OptionalIntExtensions.*
// ...
val noVal = Optional.empty
noVal.whenPresent [
	println(&quot;Here is your value: &quot;+ it)
].elseDo [
	println(&quot;Awww, no value&quot;)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the <code>ifPresentOrElse</code> extension method can be used, but this does not
have a clear visual separation which case is the if and which the else callback.</p>
</div>
<div class="paragraph">
<p>To avoid allocating objects over and over for the lambda passed to the
<code>elseDo</code> method, there are overloaded versions of the method passing on
additional parameters to the lambda. This can avoid &quot;capturing&quot; lambdas
which would create a new object on every <code>elseDo</code> call.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.Optional
import static extension de.fhg.fokus.xtensions.optional.OptionalIntExtensions.*
// ...
val captureMe = &quot;no value&quot;
val noVal = Optional.empty
noVal.whenPresent [
	println(&quot;Here is your value: &quot;+ it)
].elseDo(captureMe) [
	println(&quot;Awww, &quot; + it)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>To bridge between APIs providing an <code>Optional</code> value and ones that expect
multiple values, the extension methods <code>asIterable</code>, <code>toList</code> and <code>toSet</code>
are provided to create immutable implementations of common JVM collection APIs.</p>
</div>
<div class="paragraph">
<p>The <code>Optional</code> class has a <code>map</code> method that can map the value present in the optional
to a value of another type. Unfortunately there is no method to map to a primitive type
returning a primitive optional, such as <code>OptionalInt</code>. The extension methods <code>mapInt</code>,
<code>mapLong</code>, and <code>mapDouble</code> allow mapping to primitive options without having to
box the resulting value.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.Optional
import static extension de.fhg.fokus.xtensions.optional.OptionalIntExtensions.*
// ...
val Optional&lt;String&gt; yes = some(&quot;yesss!&quot;)
val OptionalInt lenOpt = yes.mapInt[length]
val len = lenOpt.orElse(0)
println(&quot;Length is &quot; + len)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The call chain <code>map[&#x2026;&#x200B;].orElseGet[..]</code> is pretty common. As a shortcut the method <code>mapOrGet</code>
is provided.</p>
</div>
<div class="paragraph">
<p>Some methods on Optional introduced in Java 9 are available as retrofitted extension methods.
When compiling a class using the extension method targeting Java 9, the native Optional method has precedence and will be used.
No changes in the source code has to be done to switch to the native Java 9 implementation.
The following instance methods of Optional are backported for Java 8:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#or-java.util.function.Supplier-" target="_blank">Optional&lt;T&gt; or&#x200B;(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</a></p>
</li>
<li>
<p><a href="http://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#ifPresentOrElse-java.util.function.Consumer-java.lang.Runnable-" target="_blank">void ifPresentOrElse&#x200B;(Consumer&lt;? super T&gt; action, Runnable emptyAction)</a></p>
</li>
<li>
<p><a href="http://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#stream--" target="_blank">Stream&lt;T&gt; stream&#x200B;()</a>
&#x200B;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a shortcut for the <code>or</code> extension method, the <code>||</code> operator is provided. The <code>?:</code> operator is a shortcut for the <code>orElse</code> method on Optional.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/optional/OptionalExtensions.html" target="_blank">OptionalExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_primitive_optionals">Extensions to Primitive Optionals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Extensions to the primitive versions of Optional are provided by the following classes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>de.fhg.fokus.xtensions.optional.OptionalIntExtensions
de.fhg.fokus.xtensions.optional.OptionalLongExtensions
de.fhg.fokus.xtensions.optional.OptionalDoubleExtensions</pre>
</div>
</div>
<div class="paragraph">
<p>Same as for Optional, there is a <code>some</code> alias for the <code>OptionalInt.of</code>, <code>OptionalLong.of</code>, and <code>OptionalDouble.of</code>
methods (see <a href="#_extensions_to_optional">Extensions to Optional</a>).<br>
The methods <code>noInt</code>, <code>noLong</code>, and <code>noDouble</code> provide empty primitive Optionals.</p>
</div>
<div class="paragraph">
<p>The Open JDK / Oracle JDK currently does not cache OptionalInt and OptionalLong instances in the static factory method
<code>OptionalInt.of(int)</code> and <code>OptionalLong.of(long)</code> as it is currently done for Integer creation in
<code>Integer.valueOf(int)</code>. To provide such a caching static factory methods, the
<code>OptionalIntExtensions.someOf(int)</code> and <code>OptionalLongExtensions.someOf(long)</code> method were
introduced.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static de.fhg.fokus.xtensions.optional.OptionalIntExtensions.*
// ...
if(someOf(42) === someOf(42)) {
	println(&quot;someOf caches instances&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stunningly, the primitive versions of Optional do not provide <code>map</code> and <code>filter</code> methods. These
are provided as extension methods by this library.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/optional/OptionalIntExtensions.html" target="_blank">OptionalIntExtensions</a></p>
</li>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/optional/OptionalLongExtensions.html" target="_blank">OptionalLongExtensions</a></p>
</li>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/optional/OptionalDoubleExtensions.html" target="_blank">OptionalDoubleExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_integerrange">Extensions to IntegerRange</h2>
<div class="sectionbody">
<div class="paragraph">
<p>IntegerRange is a handy type from the Xtend standard library which can
be constructed using the <code>..</code> operator. But the only way to iterate
over the elements of the range is by boxing the integers while iterating.</p>
</div>
<div class="paragraph">
<p>The extensions provided by this library allow iterating over the primitive
values of the range.</p>
</div>
<div class="paragraph">
<p>One way to iterate over the range is to use Java 8 streams, by using the
<code>stream</code> or <code>parallelStream</code> extension method from the class
<code>de.fhg.fokus.xtensions.range.RangeExtensions</code>.</p>
</div>
<div class="paragraph">
<p>Exmaple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.range.RangeExtensions.*
// ...
val range = (0..20).withStep(2)
range.stream.filter[it % 5 == 0].sum</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way to iterate over the elements of a range is to use the <code>forEachInt</code> method.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.range.RangeExtensions.*
// ...
val range = (0..20).withStep(2)
range.forEachInt [
	println(it)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>To interact with consumers expecting an <code>IntIterable</code> (see <a href="08_primitive_iterables.html">Primitive Iterables</a>), which is a generic interface
for iteration over primitive int values provided by this library, the extension method
<code>asIntIterable</code> was provided.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/range/RangeExtensions.html" target="_blank">RangeExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_pair">Extensions to Pair</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>de.fhg.fokus.xtensions.pair.PairExtensions</code> provides extension methods for the type
<a href="http://javadoc.io/page/org.eclipse.xtext/org.eclipse.xtext.xbase.lib/latest/org/eclipse/xtext/xbase/lib/Pair.html" target="_blank"><code>org.eclipse.xtext.xbase.lib.Pair</code></a>.</p>
</div>
<div class="paragraph">
<p>The with-operator <code>&#x21D2;</code> can be used to destructure a Pair into <code>key</code> and <code>value</code> and returns the input Pair.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.pair.PairExtensions.*
// ...
val pair = &quot;Foo&quot; -&gt; 3
pair =&gt; [k,v|
	println(k + &apos; -&gt; &apos; + v)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>combine</code> extension method takes a function to which key and value of a Pair is passed to,
to merge both objects. The result returned by the function will be returned by the <code>combine</code> method.
The difference to the <code>&gt;&gt;&gt;</code> operator, provided by the <a href="12_functions.html">Extensions to Functions</a>
is only that due to operator precedence calling further methods on the result needs further braces.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.pair.PairExtensions.*
// ...
val pair = &quot;Foo&quot; -&gt; 3
val s = pair.combine[k,v| k + &apos; = &apos; + v].toLowerCase
println(s)</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/pair/PairExtensions.html" target="_blank">PairExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_primitive_arrays">Extensions to Primitive Arrays</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>de.fhg.fokus.xtensions.iteration.PrimitiveArrayExtensions</code> contains extension methods for
arrays of primitive values (int, long, double) to iterate with a forEach method consuming primitive values.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.iteration.PrimitiveArrayExtensions.*
// ...
val int[] arr = #[3,4,6]
arr.forEachInt [
	println(it)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally the class allows to create primitive iterable wrapper objects (see <a href="08_primitive_iterables.html">Primitive Iterables</a>).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
The JDK class <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html" target="_blank"><code>java.util.Arrays</code></a> already contains
static <code>stream</code> methods that can be used as extension methods to create Java 8 streams from primitive arrays.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/iteration/PrimitiveArrayExtensions.html" target="_blank">PrimitiveArrayExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_streams">Extensions to Streams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>de.fhg.fokus.xtensions.stream.StreamExtensions</code> provides extension
methods to the <code>java.util.stream.Stream</code> interface.</p>
</div>
<div class="paragraph">
<p>Java 8 streams are missing a few methods known from the Xtend iterable extension methods.
The one method that is probably most often used is the method to filter by type. This can easily
be retrofitted on the Streams API by an extension method. This extension method is provided
in the <code>StreamExtensions</code> class.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StreamExtensions.*
// ...
val s = Stream.of(42, &quot;Hello&quot;, Double.NaN, &quot;World&quot;)
	.filter(String)
	.collect(Collectors.joining(&quot; &quot;))</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Since joining Strings is a common operation, the <code>StringStreamExtensions</code> allow to call <code>join</code>
directly on the Stream. Have a look at <a href="#_extensions_to_streams_of_strings">Extensions to Streams of Strings</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some other collectors, especially the ones bridging to the collections API are also used very often,
but using the collect method with the methods from the <code>Collectors</code> class is a bit verbose.<br>
As a shortcut the <code>StreamExtensions</code> class provides <code>toList</code>, <code>toSet</code>, and <code>toCollection</code>
extension methods to the <code>Stream</code> class.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StreamExtensions.*
// ...
val list = Stream.of(&quot;Foo&quot;, &quot;Hello&quot; , &quot;Boo&quot;, &quot;World&quot;)
	.filter[!contains(&quot;oo&quot;)]
	.map[toUpperCase]
	.toList</code></pre>
</div>
</div>
<div class="paragraph">
<p>A useful extension method from Xtend on <code>java.lang.Iterable</code> is the <code>filterNull</code> method, which
produces a view for an iterable excluding the <code>null</code> elements. An equivalent is not provided on the
<code>Stream</code> interface. This library provides such an extension method on stream.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StreamExtensions.*
// ...
Stream.of(42.0, null, &quot;foo&quot;, 100_000_000_000bi)
	.filterNull
	.forEach [
		// it is guaranteed to be != null
		println(it.toString.toUpperCase)
	]</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a shortcut for the
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#concat-java.util.stream.Stream-java.util.stream.Stream-" target="_blank">concat</a>
method the <code>StreamExtensions</code> class provides a <code>+</code> operator.</p>
</div>
<div class="paragraph">
<p>The <code>flatMap</code> method on <code>Stream</code> expects a function mapping to another stream. Oftentimes data structures
do not provide streams, but <code>Collection</code> or <code>Iterable</code> types, so the user has to create a stream based on
them. This usually leads to some visual noise. This library provides a <code>flatMap</code> extension method which allows to
be called with a function providing an iterable, since it is known how to construct a stream from an iterable.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import org.eclipse.xtend.lib.annotations.Accessors
import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor
import java.util.stream.Stream
import java.util.function.Function
import static java.util.stream.Collectors.*
import static extension de.fhg.fokus.xtensions.stream.StreamExtensions.*
// ...
val stream = Stream.of(
	new Developer(&quot;Max&quot;, #{&quot;Java&quot;, &quot;Xtend&quot;, &quot;Rust&quot;, &quot;C++&quot;}),
	new Developer(&quot;Joe&quot;, #{&quot;Xtend&quot;, &quot;JavaScript&quot;, &quot;Dart&quot;})
);

// Mapping language name to number of occurrences
val Map&lt;String, Long&gt; langPopularity = stream
	.flatMap[languages] (1)
	.collect(groupingBy(Function.identity, counting))

langPopularity.entrySet
	.stream
	.max(Map.Entry.comparingByValue)
	.ifPresent [
		println(&apos;&apos;&apos;Most pobular language: &#xAB;it.key&#xBB;, count: &#xAB;it.value&#xBB;&apos;&apos;&apos;)
	]

// ...

@FinalFieldsConstructor
@Accessors
static class Developer {
	val String name
	val Set&lt;String&gt; languages;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Here <code>languages</code> can be returned directly instead of <code>languages.stream</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sometimes it is interesting to produce the cartesian product of two containers of elements. To produce
all combinations of the elements of a stream with the elements of an <code>Iterable</code> (or a different source
of a stream) this library provides the <code>combinations</code> extension methods. If no merging function is
provided, the <code>combinations</code> extension methods will create a <code>org.eclipse.xtext.xbase.lib.Pair</code>
object for each combination. If a merging function is provided, the resulting stream will hold the result
of the merge of each combination.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StreamExtensions.*
// ...
Stream.of(&quot;foo&quot;, &quot;bar&quot;)
	.combinations(#[&quot;fun&quot;, &quot;boo&quot;, &quot;faz&quot;])[a,b|a+b]
	.forEach[
		println(it)
	]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java 9 provides a static factory methods for an infinite stream
<a href="http://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#iterate-T-java.util.function.UnaryOperator-" target="_blank">Stream.iterate(T,UnaryOperator&lt;T&gt;)</a>. A function with the same functionality is provided via <code>StreamExtensions</code>.
There is even an overloaded version of the static method that can be written as if the method would exist in the Stream class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">// This is using Java 8
import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StreamExtensions.*
// ...
Stream.iterate(&quot;na &quot;)[it + it]
	.filter[length &gt; 15]
	.findFirst
	.ifPresent [
		println(it + &quot;Batman!&quot;)
	]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method can be handy traversing a nested data structure of same-type elements (e.g. moving up a containment hierarchy).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/stream/StreamExtensions.html" target="_blank">StreamExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_streams_of_strings">Extensions to Streams of Strings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since Xtend can provide extension methods specifically for specializations of generic types,
it is possible to provide methods only available for <code>java.util.stream.Stream&lt;String&gt;</code>.
The class <code>de.fhg.fokus.xtensions.stream.StringStreamExtensions</code> provides such extension methods.</p>
</div>
<div class="paragraph">
<p>The most used collectors on streams of strings are the joining collectors from <code>java.util.stream.Collectors</code>.
To make these easy to use <code>join</code> methods have been introduced as extension methods to <code>Stream&lt;String&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StringStreamExtensions.*
// ...
val joined = Stream.of(&quot;Hello&quot;, &quot;Xtend&quot;, &quot;aficionados&quot;).join(&quot; &quot;)
println(joined)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another operation often performed on streams of strings is filtering it based on a regular expression.
This is provided via the extension method <code>matching</code>. The pattern can either be passed in as string
or as a pre-compiled <code>java.util.regex.Pattern</code></p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StringStreamExtensions.*
// ...
Stream.of(&quot;foo&quot;, &quot;bar&quot;, &quot;kazoo&quot;, &quot;baz&quot;, &quot;oomph&quot;, &quot;shoot&quot;)
	.matching(&quot;.+oo.*&quot;)
	.forEach [
		println(it)
	]</code></pre>
</div>
</div>
<div class="paragraph">
<p>When splitting strings provided as a stream it is handy to get an operation providing a single
stream of the result of splitting all elements, which also works as lazy as possible. A use case
would be to to use <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-" target="_blank">Files.lines(Path)</a>
and then split the resulting lines of this operation.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StringStreamExtensions.*
// ...
Stream.of(&quot;Hello users&quot;, &quot;welcome to this demo&quot;, &quot;hope it helps&quot;)
	.flatSplit(&quot;\\s+&quot;)
	.forEach [
		println(it)
	]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes it is also wanted to find all matches of a regular expressions in a stream of strings and
produce a single stream of all the matches in all strings. This can be done using the <code>flatMatches</code>
extension method. The pattern of the regular expression can either be provided as a string or as a
pre-compiled <code>java.util.regex.Pattern</code> object.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.regex.Pattern
import java.util.stream.Stream
import static extension de.fhg.fokus.xtensions.stream.StringStreamExtensions.*
// ...
val Pattern pattern = Pattern.compile(&quot;(\\woo)&quot;)
Stream.of(&quot;Welcome to the zoo&quot;, &quot;Where cows do moo&quot;, &quot;And all animals poo&quot;)
	.flatMatches(pattern)
	.forEach [
		println(it)
	]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/stream/StringStreamExtensions.html" target="_blank">StringStreamExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_iterable">Extensions to Iterable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>de.fhg.fokus.xtensions.iteration.IterableExtensions</code> class provides extension methods to
<code>java.lang.Iterable</code></p>
</div>
<div class="paragraph">
<p>Unfortunately the <code>java.lang.Iterable</code> interface does not provide a (default)
method for creating a <code>java.lang.Stream</code>. It does provide a method to obtain a
<code>Spliterator</code> which can be used to create a stream, but this is rather unpleasant to use.<br>
The <code>IterableExtensions</code> class provides the <code>stream</code> extension method to easily create
a stream from an iterable. This method will first check if the given iterable is instance of
<code>java.util.Collection</code>, since this class does provide a default <code>stream</code> method,
otherwise it will construct a stream from the spliterator provided by the iterable.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.iteration.IterableExtensions.*
import java.util.OptionalDouble
//...
#[&quot;foo&quot;, null, &quot;BAR&quot;, &quot;bazzzz&quot;]
	.filterNull
	.averageSize
	.ifPresent [
		println(&apos;&apos;&apos;The average string lenght is &#xAB;it&#xBB;&apos;&apos;&apos;)
	]

//...

private def OptionalDouble averageSize(Iterable&lt;String&gt; strings) {
	strings.stream.mapToInt[length].average (1)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>In this line the extension method <code>stream</code> is called on the iterable <code>strings</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Analogous to the <code>stream</code> method the <code>IterableExtensions</code> class also provides a <code>parallelStream</code> method.</p>
</div>
<div class="paragraph">
<p>It is also possible to map an iterable to a primitive iterable
(see <a href="08_primitive_iterables.html#from-iterables">Primitve Iterables / From Iterables</a>).</p>
</div>
<div class="paragraph">
<p>The JDK since Java 8 provides the class <code>java.util.stream.Collector</code> which can be used with streams
to perform a reduction operation over all elements in a stream. The class <code>java.util.stream.Collectors</code>
already provides constructor methods for a bunch of useful collectors. The <code>IterableExtensions</code> class
of this library provides a <code>collect</code> extension method directly for <code>Iterable</code> to easily reduce the elements
of the iterable.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static java.util.stream.Collectors.*
import static extension de.fhg.fokus.xtensions.iteration.IterableExtensions.*
// ...
val Iterable&lt;String&gt; strings = #[&quot;fooooo&quot;, &quot;baar&quot;, &quot;baz&quot;]
val summary = strings.collect(summarizingInt[length])
println(&quot;Average length: &quot; + summary.average)
println(&quot;Max length: &quot; + summary.max)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A fairly common task in Model-to-Model transformations is to find objects of one type that are not referenced by
some other objects. This is usually done by navigation over all elements in a model, finding all elements of both
types and then finding the elements that are actually not referenced. This is typically done by traversing the
complete model twice to find the elements of both types. This can be an expensive operation if the input model
is large. The solution is to traverse the model just once and group the elements according to their type.</p>
</div>
<div class="paragraph">
<p>This library provides a method allowing exactly this. The method <code>groupIntoListBy</code> and <code>groupIntoSetBy</code>
groups elements of an iterable by their type.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val foo = &quot;foo&quot;
val bar = &quot;bar&quot;
val baz = &quot;baz&quot;
val traverseMe = #[foo, #[bar], baz, #[foo], bar]
val groups = traverseMe.groupIntoSetBy(String, List)

val Set&lt;String&gt; strings = groups.get(String)
val Set&lt;List&gt; lists = groups.get(List)
val inNoList = strings
	.filter[str|
		!lists.exists[it.contains(str)]
	].toList
println(&quot;Elements contained in no list: &quot; + inNoList)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To exclude elements of one <code>Iterable</code> from another, the method <code>withoutAll</code> can be used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val s = #[&quot;I&quot;, &quot;boo&quot;, &quot;pity&quot;, &quot;char&quot;, &quot;the&quot;, &quot;fool&quot;]
	.withoutAll(#{&quot;boo&quot;, &quot;char&quot;})
	.join(&quot; &quot;)
println(s)</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Performance of <code>withoutAll</code> is best when using an appropriate <code>java.util.Set</code>, such as <code>HashSet</code> for the elements to exclude.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To partition the elements of an <code>Iterable</code> based on a predicate or the class (elements are tested to be instance of) into two parts:
selected and rejected. The selected part will contain the elements for which the predicate evaluates to <code>true</code> or elements are instance
of the given partitioning class. The rejected part will contain the other elements.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.iteration.IterableExtensions.*
// ...
val char[] chars = #[0x0020 as char, 0x0034 as char]
val List&lt;CharSequence&gt; list = #[
	&quot;Hello&quot;,
	new StringBuilder().append(chars),
	&quot;Xtend&quot;,
	new StringBuilder().append(0x0032 as char)
]
list.partitionBy(String) =&gt; [
	println(&apos;&apos;&apos;Selected: &quot;&#xAB;selected.join(&quot; &quot;)&#xBB;&quot;&apos;&apos;&apos;)
	println(&apos;&apos;&apos;Rejected: &quot;&#xAB;rejected.join(&quot;&quot;)&#xBB;&quot;&apos;&apos;&apos;)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>For both versions of the <code>partitionBy</code> method there exist overloads that take instances of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html" target="_blank"><code>Collector</code></a>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.iteration.IterableExtensions.*
import static java.util.stream.Collectors.*
import java.util.Set
import java.util.List
// ...
val list = #[&quot;foo&quot;, &quot;bla&quot;, &quot;foo&quot;, &quot;hui&quot;, &quot;fun&quot;]
val partition = list.partitionBy([startsWith(&quot;f&quot;)], toSet, toList)
val Set&lt;String&gt; selected = partition.selected
val List&lt;String&gt; rejected = partition.rejected
println(&quot;Unique words starting with &apos;f&apos; : &quot; + selected.join(&quot;, &quot;))
println(&quot;Other words: &quot; + rejected.join(&quot;, &quot;))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-" target="_blank"><code>Collectors#partitioningBy</code></a> Collector from the JDK aggregates into a <code>Map&lt;Boolean,List&lt;T&gt;&gt;</code> where <code>T</code> is the type of the elements in a collected stream. Another <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-java.util.stream.Collector-" target="_blank"><code>partitioningBy</code></a> overload from <code>Collectors</code> aggregates the map values and returns a <code>Map&lt;Boolean,D&gt;</code> where <code>D</code> is the aggregation of a &quot;downstream&quot; <code>Collector</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val list = #[&quot;foo&quot;, &quot;bla&quot;, &quot;foo&quot;, &quot;hui&quot;, &quot;fun&quot;]
val partition = list.partitionBy([startsWith(&quot;f&quot;)], Collectors::toSet, Collectors::toList)
val Set&lt;String&gt; selected = partition.selected
val List&lt;String&gt; rejected = partition.rejected
println(&quot;Unique words starting with &apos;f&apos; : &quot; + selected.join(&quot;, &quot;))
println(&quot;Other words: &quot; + rejected.join(&quot;, &quot;))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To allow a similar workflow to the JDK version, for the <code>Partition</code> of this library a <code>asMap</code> extension method is provided
for <code>Partitions</code> having the same type for the selected and rejected part. The other way around an extension method is provided
to wrap a <code>Map&lt;Boolean,X&gt;</code> into a <code>Partition&lt;X,X&gt;</code>.</p>
</div>
<div class="paragraph">
<p>To add elements from an <code>Iterable</code> to one or more collections, the <code>into</code> extension method is provided by the class <code>IterableExtensions</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val namesWithB = newArrayList(&quot;Barbara&quot;, &quot;Bob&quot;, &quot;Brian&quot;)
val newNames = #[&quot;Justin&quot;, &quot;Anna&quot;, &quot;Bruce&quot;, &quot;Chris&quot;, &quot;Becky&quot;]
newNames
	.filter[it.toFirstLower.startsWith(&quot;b&quot;)]
	.into(namesWithB)

namesWithB.forEach[
	println(it)
]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/iteration/IterableExtensions.html" target="_blank">IterableExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_iterator">Extensions to Iterator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To map from an Iterator (over references) to a <a href="https://docs.oracle.com/javase/9/docs/api/java/util/PrimitiveIterator.html" target="_blank"><code>PrimitiveIterator</code>s</a>,
the class <code>de.fhg.fokus.xtensions.iteration.IteratorExtensions</code> provides the methods <code>mapInt</code>, <code>mapLong</code> and <code>mapDouble</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static java.util.stream.Collectors.*
import static extension de.fhg.fokus.xtensions.iteration.IteratorExtensions.*
// ...
val Iterable&lt;String&gt; strings = #[&quot;fooooo&quot;, &quot;baar&quot;, &quot;baz&quot;]
val summary = strings.iterator.mapInt[length].summarize
println(&quot;Size of longest string is &quot; + summary.max)</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
See <a href="09_primitive_iterators.html">Primitive Iterators</a> for more information on the <code>summarize</code> extension function.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To exclude elements of one <code>Iterable</code> from the sequence provided by an <code>Iterator</code>, the method <code>withoutAll</code> can be used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val s = #[&quot;I&quot;, &quot;boo&quot;, &quot;pity&quot;, &quot;char&quot;, &quot;the&quot;, &quot;fool&quot;]
	.iterator
	.withoutAll(#{&quot;boo&quot;, &quot;char&quot;})
	.join(&quot; &quot;)
println(s)</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Performance of <code>withoutAll</code> is best when using an appropriate <code>java.util.Set</code>, such as <code>HashSet</code> for the elements to exclude.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To partition the elements provided by an iterator based on a predicate or the class (elements are tested to be instance of) into two parts:
selected and rejected. The selected part will contain the elements for which the predicate evaluates to <code>true</code> or elements are instance
of the given partitioning class. The rejected part will contain the other elements.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.iteration.IteratorExtensions.*
// ...
val char[] chars = #[0x0020 as char, 0x0034 as char]
val List&lt;CharSequence&gt; list = #[
	&quot;Hello&quot;,
	new StringBuilder().append(chars),
	&quot;Xtend&quot;,
	new StringBuilder().append(0x0032 as char)
]
list.iterator.partitionBy(String) =&gt; [
	println(&apos;&apos;&apos;Selected: &quot;&#xAB;selected.join(&quot; &quot;)&#xBB;&quot;&apos;&apos;&apos;)
	println(&apos;&apos;&apos;Rejected: &quot;&#xAB;rejected.join(&quot;&quot;)&#xBB;&quot;&apos;&apos;&apos;)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>For both versions of the <code>partitionBy</code> method there exist overloads that take instances of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html" target="_blank"><code>Collector</code></a>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.iteration.IteratorExtensions.*
import static java.util.stream.Collectors.*
import java.util.Set
import java.util.List
// ...
val list = #[&quot;foo&quot;, &quot;bla&quot;, &quot;foo&quot;, &quot;hui&quot;, &quot;fun&quot;]
val partition = list.iterator.partitionBy([startsWith(&quot;f&quot;)], toSet, toList)
val Set&lt;String&gt; selected = partition.selected
val List&lt;String&gt; rejected = partition.rejected
println(&quot;Unique words starting with &apos;f&apos; : &quot; + selected.join(&quot;, &quot;))
println(&quot;Other words: &quot; + rejected.join(&quot;, &quot;))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-" target="_blank"><code>Collectors#partitioningBy</code></a> Collector from the JDK aggregates into a <code>Map&lt;Boolean,List&lt;T&gt;&gt;</code> where <code>T</code> is the type of the elements in a collected stream. Another <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-java.util.stream.Collector-" target="_blank"><code>partitioningBy</code></a> overload from <code>Collectors</code> aggregates the map values and returns a <code>Map&lt;Boolean,D&gt;</code> where <code>D</code> is the aggregation of a &quot;downstream&quot; <code>Collector</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val list = #[&quot;foo&quot;, &quot;bla&quot;, &quot;foo&quot;, &quot;hui&quot;, &quot;fun&quot;]
val partition = list.iterator.partitionBy([startsWith(&quot;f&quot;)], Collectors::toSet, Collectors::toList)
val Set&lt;String&gt; selected = partition.selected
val List&lt;String&gt; rejected = partition.rejected
println(&quot;Unique words starting with &apos;f&apos; : &quot; + selected.join(&quot;, &quot;))
println(&quot;Other words: &quot; + rejected.join(&quot;, &quot;))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To allow a similar workflow to the JDK version, for the <code>Partition</code> of this library a <code>asMap</code> extension method is provided
for <code>Partitions</code> having the same type for the selected and rejected part. The other way around an extension method is provided
to wrap a <code>Map&lt;Boolean,X&gt;</code> into a <code>Partition&lt;X,X&gt;</code>.</p>
</div>
<div class="paragraph">
<p>To add elements from an <code>Iterator</code> to one or more collections, the <code>into</code> extension method is provided by the class <code>IterableExtensions</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val namesWithB = newArrayList(&quot;Barbara&quot;, &quot;Bob&quot;, &quot;Brian&quot;)
val newNames = #[&quot;Justin&quot;, &quot;Anna&quot;, &quot;Bruce&quot;, &quot;Chris&quot;, &quot;Becky&quot;]
newNames.iterator
	.filter[it.toFirstLower.startsWith(&quot;b&quot;)]
	.into(namesWithB)

namesWithB.forEach[
	println(it)
]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/iteration/IteratorExtensions.html" target="_blank">IteratorExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_primitive_iterables">Primitive Iterables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The JDK provides a generic <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank"><code>java.util.Iterator&lt;T&gt;</code></a> interface and
primitive versions of the Iterator in form of the sub-interfaces of
<a href="http://docs.oracle.com/javase/8/docs/api/java/util/PrimitiveIterator.html" target="_blank"><code>java.util.PrimitiveIterator&lt;T,T_CONS&gt;</code></a>. However,
there are no primitive versions of the <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" target="_blank"><code>java.lang.Iterable&lt;T&gt;</code></a>
interface, constructing primitive iterators.</p>
</div>
<div class="paragraph">
<p>So the JDK is missing an interface to abstract over &quot;a bunch&quot; of primitive numbers to iterate over. A primitive iterator or primitive
stream can only traversed once, which is not very satisfying in many cases. Ideally there should be in interface allowing the
iteration over a (possibly infinite) sequence of primitive numbers. We want to be able to get a primitive iterator, a primitive
stream, or directly iterate over the elements with a <code>forEach</code> method. A set of these interfaces is provided in package
<code>de.fhg.fokus.xtensions.iteration</code>.<br>
The primitive Iterable versions provided in the package all specialize <code>java.lang.Iterable</code> with the boxed
number type, but also provide specialized functions for providing primitive iterators, primitive streams, and
forEach methods that do not rely on boxing the primitive values when passing them on to the consumer.</p>
</div>
<div class="paragraph">
<p>In the following sections we will explore the ways to create those primitive Iterables.
Primitive Iterables can be created &#x2026;&#x200B;</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#from-iterables">From Iterables</a></p>
</li>
<li>
<p><a href="#_from_arrays">From Arrays</a></p>
</li>
<li>
<p><a href="#_from_computations">From Computations</a></p>
</li>
<li>
<p><a href="#_from_xtend_ranges">From Xtend Ranges</a></p>
</li>
<li>
<p>or <a href="#_from_primitive_optionals">From Primitive Optionals</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Examples for usage of primitive Iterables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.PrimitiveIterator
import static extension de.fhg.fokus.xtensions.iteration.IntIterable.*
// ...

def printHex(IntIterable ints) {
	ints.forEachInt [
		val hex = Integer.toHexString(it)
		println(hex)
	]
}

def printHex(IntIterable ints, int limit) {
	val PrimitiveIterator.OfInt iter = ints.iterator
	for(var counter = 0; iter.hasNext &amp;&amp; counter &lt; limit; counter++) {
		val i = iter.nextInt
		val hex = Integer.toHexString(i)
		println(hex)
	}
}

def printHexOdd(IntIterable ints) {
	val IntStream s = ints.stream.filter[it % 2 == 1]
	s.forEach [
		val hex = Long.toHexString(it)
		println(hex)
	]
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="from-iterables">From Iterables</h3>
<div class="paragraph">
<p>Iterables can be mapped to primitive iterables by the special map extension functions <code>mapInt</code>, <code>mapLong</code>
and <code>mapDouble</code> defined in <code>de.fhg.fokus.xtensions.iteration.IterableExtensions</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.iteration.IterableExtensions.*
import de.fhg.fokus.xtensions.iteration.IntIterable
// ...
val IntIterable lengths = newArrayList(&quot;foo&quot;, &quot;baaaar&quot;, &quot;bz&quot;).mapInt[length]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_from_arrays">From Arrays</h3>
<div class="paragraph">
<p>The <code>asIntIterable</code> extension method method creates a primitive iterable for primitive arrays.
There are two versions: One version creates an iterable over the complete array, the other one produces
an iterable over a section of the array. The section can be specified by defining the start index and
an excluding end index.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.iteration.PrimitiveArrayExtensions.*
import de.fhg.fokus.xtensions.iteration.IntIterable
// ...
val int[] arr = #[0,2,4,19,-10,10_000,Integer.MAX_VALUE,Integer.MIN_VALUE]
var IntIterable ints = arr.asIntIterable(1, arr.length - 1)  // omit first and last element</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_from_computations">From Computations</h3>
<div class="paragraph">
<p>In following we are using IntIterable to show how to create computed primitive iterables,
but respective factory methods are also available on LongIterable and DoubleIterable.</p>
</div>
<div class="paragraph">
<p>To create an IntIterable representing an infinite number of int values the static <code>generate</code>
factory method can be used. This method has to provided with a function which itself provides
an <code>IntSupplier</code>. The function will be called each time a <code>PrimitiveIterator.OfInt</code>
is needed or an <code>IntStream</code> is created from the <code>IntIterable</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import de.fhg.fokus.xtensions.iteration.IntIterable
// ...
val IntIterable ints = IntIterable.generate [
	val rand = new Random;
	[rand.nextInt]
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>For IntIterables of infinite int values that can be simply computed from a
seed value and a mapping function from the previous to the next value, the
<code>iterate</code> factory method can be used. The seed value provided will be returned
as the first element of the iterable.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import de.fhg.fokus.xtensions.iteration.IntIterable
// ...
val IntIterable ints = IntIterable.iterate(1)[it * 2]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a finite IntIterable is needed that can be constructed similar to the classical
for-loop, the <code>iterate</code> method with three parameters can be used. The first argument
defines the first (seed) value , the second argument defines the termination condition.
While this condition holds a next value is provided. If the condition does not hold
for the initial value, an empty IntIterable is created.
The third argument defines the function calculating the next value from the previous one.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import de.fhg.fokus.xtensions.iteration.IntIterable
// ...
val IntIterable ints = IntIterable.iterate(0, [it&lt;=10], [it+2])
// will provide values 0, 2, 4, 6, 8, and 10</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_from_xtend_ranges">From Xtend Ranges</h3>
<div class="paragraph">
<p>Creating iterables from <code>org.eclipse.xtext.xbase.lib.IntegerRange</code> can be done via the extensions
class <code>de.fhg.fokus.xtensions.range.RangeExtensions</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static org.eclipse.xtext.xbase.lib.IntegerRange.*
// ...
val IntIterable iter = (0..50).withStep(2).asIntIterable</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creating an iterable from an <code>org.eclipse.xtext.xbase.lib.ExclusiveRange</code> is currently not supported
due to the public API limitations on that class.</p>
</div>
</div>
<div class="sect2">
<h3 id="_from_primitive_optionals">From Primitive Optionals</h3>
<div class="paragraph">
<p>The extension classes for primitive Optionals allow the creation of primitive iterables allowing
iteration over either one or no value, depending on the source Optional.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.optional.OptionalIntExtensions.*
// ...
val IntItreable ints = some(42).asIterable</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/iteration/DoubleIterable.html" target="_blank">DoubleIterable</a></p>
</li>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/iteration/IntIterable.html" target="_blank">IntIterable</a></p>
</li>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/iteration/LongIterable.html" target="_blank">LongIterable</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_primitiveiterators">Extensions to PrimitiveIterators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The primitive iterators defined in the JDK as sub-interfaces of <code>java.util.PrimitiveIterator</code>
do not provide combinators like the ones provided by Xtend. These combinators, however, do take some
efforts to implement. Instread, this library provides the class
<code>de.fhg.fokus.xtensions.iteration.PrimitiveIteratorExtensions</code> provides methods to
create primitive streams (from <code>java.util.stream</code>) for the remaining elements of a given iterator via the
extension methods <code>streamRemaining</code> or <code>parallelStreamRemaining</code>. Note that the method <code>streamRemaining</code>
does <strong>not</strong> guarantee that the elements provided by the returned stream are actually taken from the originating
iterator. If the underlying iterator implementation is known, the framework may construct a stream that may have
better characteristics in some way. If elements should actually be removed from the originating iterator, the
<code>streamRemainingExhaustive</code> method can be used.</p>
</div>
<div class="paragraph">
<p>To create a summary object providing the minimum value, maximum value, average value, sum value, and count of elements,
the <code>PrimitiveIteratorExtensions</code> class provides a <code>summarize</code> function for all three primitive iterators.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val range = 1..100
val summary = range.intIterator.summarize
println(&apos;&apos;&apos;Sum of elements in range [&#xAB;range.start&#xBB;..&#xAB;range.end&#xBB;] is &#xAB;summary.sum&#xBB;&apos;&apos;&apos;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tip: If you want to know more about the extension methods available on <code>IntegerRange</code>, have a look at chapter <a href="02_ranges.html">Extensions to IntegerRange</a></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/iteration/PrimitiveIteratorExtensions.html" target="_blank">PrimitiveIteratorExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_string">Extensions to String</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>de.fhg.fokus.xtensions.string.StringSplitExtensions</code> provides extension methods
for <code>java.lang.String</code> allowing to lazily split a string value.</p>
</div>
<div class="paragraph">
<p>The extension method <code>splitIt</code> returns an <code>Iterator</code> which lazily performs string split
operations based on a regular expression (same <code>String#split(String)</code>) would do, but
lazily. This allows the use of Iterator extension methods provided by Xtend and to stop splitting
a string when a condition is met without splitting the complete input string beforehand.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.string.StringSplitExtensions.*
// ...
val Iterator&lt;String&gt; i = &quot;foozoobaar&quot;.splitIt(&quot;(?&lt;=oo)&quot;)
i.takeWhile[!startsWith(&quot;b&quot;)].forEach[
	println(it)
]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>If a split pattern is known in advance the following is possible with the JDK types to obtain a Stream of split elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.regex.Pattern
// ...
extension val pattern = Pattern.compile(&quot;mypattern&quot;)
// ...
&quot;tosplit&quot;.splitAsStream  // actually calls pattern.splitAsStream(&quot;tosplit&quot;)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a pattern String has to be produced dynamically, the extension method <code>splitAsStream</code> is provided
as a shortcut for the sequence of calls from above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.string.StringSplitExtensions.*
// ...
val String patternStr = ... // dynamically created pattern
&quot;tosplit&quot;.splitAsStream(patternStr)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>de.fhg.fokus.xtensions.string.SptringMatchExtensions</code> provides extension methods to
<code>java.lang.String</code>, allowing to match regular expressions lazily via iterators.</p>
</div>
<div class="paragraph">
<p>To manually get matches for a pattern from an input string with JDK classes the following sequence has to be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.regex.Pattern
// ...
val String input = &quot;foo bar boo&quot;
val Pattern pattern = Pattern.compile(&quot;(\\woo)&quot;)
val matcher = pattern.matcher(input)
while(matcher.find) {
	val match = input.subSequence(matcher.start, matcher.end)
	// Do something with match
	println(match)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The extension method <code>matchIt</code> elegantly wraps this usage pattern into an Iterator, so the Xtend combinators
can be used on them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.string.StringMatchExtensions.*
import java.util.regex.Pattern
// ...
val String input = &quot;foo bar boo&quot;
val Pattern pattern = Pattern.compile(&quot;(\\woo)&quot;)
input.matchIt(pattern).forEach [
	println(it)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>matchIt</code> is overloaded to also take a string of the pattern, which internally compiles
it to a pattern.</p>
</div>
<div class="paragraph">
<p>Having a stream of <a href="http://docs.oracle.com/javase/9/docs/api/java/util/regex/MatchResult.html" target="_blank"><code>MatchResult</code></a>s
for a pattern applied to a given input string can be achieved  with the <code>matchResultIt</code> extension method.
This can be useful, if other group captures have to be accessed when handling matches.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/string/StringSplitExtensions.html" target="_blank">StringSplitExtensions</a></p>
</li>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/string/StringMatchExtensions.html" target="_blank">StringMatchExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_duration">Extensions to Duration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>de.fhg.fokus.xtensions.datetime.DurationExtensions</code> provides static extension
method for the JDK class <code>java.time.Duration</code></p>
</div>
<div class="paragraph">
<p>Since Java does not allow operator overloading, the Duration class provides many methods with names
corresponding to operators, like <code>plus</code>, <code>minus</code>, <code>dividedBy</code>, <code>multipliedBy</code>, and <code>negated</code>.
Since Xtend does allow operator overloading for the corresponding operators, aliases for the operators
<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, and unary <code>-</code> are defined.</p>
</div>
<div class="paragraph">
<p>The Duration class also provides static factory methods for durations of a given time units
(e.g. <a href="http://docs.oracle.com/javase/9/docs/api/java/time/Duration.html#ofNanos-long-" target="_blank"><code>Duration ofNanos(long nanos)</code></a>).<br>
To make these constructions more easy to read, the <code>DurationExtensions</code> class provides extension methods
to the <code>long</code> type.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.datetime.DurationExtensions.*
import java.time.Duration
// ...
val Duration twoPointFiveSeconds = 2.seconds + 500.milliseconds</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/datetime/DurationExtensions.html" target="_blank">DurationExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_functions">Extensions to Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Xtend provides own functional interfaces in the
<a href="http://javadoc.io/page/org.eclipse.xtext/org.eclipse.xtext.xbase.lib/latest/org/eclipse/xtext/xbase/lib/Functions.html" target="_blank"><code>org.eclipse.xtext.xbase.lib.Functions</code></a>
Interface. These are used all over the Xtend standard library and they allow a compact declaration syntax, e.g. the type
<code>Function1&lt;? super String,? extends String&gt;</code> can be written as <code>(String)&#x21D2;String</code>.
Extensions to Xtends functional interfaces are provided in <code>de.fhg.fokus.xtensions.function.FunctionExtensions</code>.</p>
</div>
<div class="paragraph">
<p>This library&#x2019;s <code>FunctionExtensions</code> provides another overload of the method <code>andThen</code> which allows composition of a
<code>()&#x21D2;T</code> function with a <code>(T)&#x21D2;U</code> function, resulting in a composed <code>()&#x21D2;U</code> function.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.function.FunctionExtensions.*
import java.time.LocalDate
// ...
val ()=&gt;LocalDate inOneYear = [LocalDate.now.plusYears(1)]
val (LocalDate)=&gt;String yearString = [it.year.toString]
val ()=&gt;String nextYear = inOneYear.andThen(yearString)
println(nextYear.apply)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inspired by the <code>|&gt;</code> operator of F# and Elixir, this library introduces the <code>&gt;&gt;&gt;</code> operator,
which can be seen as a &quot;pipe through&quot; operator. It takes the value of the left hand side and
calls the function on the right hand side with the value. This means that</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val (X)=&gt;Y f = ...
val X x = ...
x &gt;&gt;&gt; f
// equal to
f.apply(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is especially handy when having to call several functions in a row,
so <code>a.apply(b.apply(x))</code> can be written as <code>x &gt;&gt;&gt; b &gt;&gt;&gt; a</code>.
It can also be useful to transforming transform the value returned by a method call
before assigning it to a final variable without having to define a separate method.
It can also be used like the <code>&#x21D2;</code> operator (to have a value as a context value <code>it</code>)
just with a different return value.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.function.FunctionExtensions.*
import java.nio.file.Paths
// ...
val path = System.getProperty(&quot;user.home&quot;) &gt;&gt;&gt; [Paths.get(it)]
println(path.parent)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&gt;&gt;&gt;</code> operator is overloaded to also destructure a <code>Pair</code> value into <code>key</code> and <code>value</code> on call.
This means that the left hand side of the operator must be evaluated to a value of type Pair and the
right hand side of the operator must be a function with two parameters of the types of key and value of
the Pair <code>(K,V)&#x21D2;Y</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.function.FunctionExtensions.*
// ...
val list = #[&quot;foo&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;bar&quot;]
list.splitHead
	&gt;&gt;&gt; [head,tail| head -&gt; tail.toSet.size]
	&gt;&gt;&gt; [head,remaining| &apos;&apos;&apos;Head: &quot;&#xAB;head&#xBB;&quot;, remaining: &#xAB;remaining&#xBB; unique elements&apos;&apos;&apos;]
	&gt;&gt;&gt; [println(it)]

// ...

def &lt;T&gt; Pair&lt;T,Iterable&lt;T&gt;&gt; splitHead(Iterable&lt;T&gt; elements) {
	elements.head -&gt; elements.tail
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To compose functions, the shortcut operators <code>&gt;&gt;</code> for <code>andThen</code> and <code>&lt;&lt;</code> for <code>compose</code>
were introduced.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.function.FunctionExtensions.*
import java.time.LocalDate
// ...
val (LocalDate)=&gt;LocalDate oneYearLater = [it.plusYears(1)]
val (LocalDate)=&gt;String yearString = [it.year.toString]

val (LocalDate)=&gt;String yearAfter = oneYearLater &gt;&gt; yearString

LocalDate.now &gt;&gt;&gt; yearAfter &gt;&gt;&gt; [println(it)]</code></pre>
</div>
</div>
<div class="paragraph">
<p>When working with the Xtend extension methods on <code>Iterator</code> and <code>Iterable</code> sometimes
<code>(X)&#x21D2;Boolean</code> types are needed, e.g. for the <code>exists</code> and <code>filter</code> combinator.
Unfortunately the Xtend boolean functions do not have the composition functions as the
Java 8 <code>java.util.function.Predicate</code> interface. This library&#x2019;s <code>FunctionExtensions</code>
class does provides the equivalent methods <code>and</code>, <code>or</code>, and <code>negate</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.function.FunctionExtensions.*
// ...
val (String)=&gt;boolean notThere = [it.nullOrEmpty]
val (String)=&gt;boolean tooShort = [it.length &lt; 3]
val (String)=&gt;boolean valid = notThere.or(tooShort).negate
#[&quot;ay&quot;, &quot;caramba&quot;, null, &quot;we&quot;, &quot;fools&quot;]
	.filter(valid)
	.forEach[
		println(it)
	]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/function/FunctionExtensions.html" target="_blank">FunctionExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensions_to_completablefuture">Extensions to CompletableFuture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some might complain that the <code>java.util.concurrent.CompletionStage</code>/<code>java.util.concurrent.CompletableFuture</code>
API surface is too large and difficult to wrap your head around. But actually many methods are similar and certain
use cases are verbose to express with the given methods. Therefore we provide a couple of extension methods to
make certain actions more convenient on <code>CompletableFuture</code>. These extension methods are provided via the class
<code>de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions</code>.</p>
</div>
<div class="paragraph">
<p>The first thing one usually notices is that there are three methods that to handle the success case case
on <code>CompletableFuture</code>: <code>thenApply</code>, <code>thenAccept</code>, and <code>thenRun</code>. These methods are only named
differently, because the Java compiler cannot figure out which functional interface a lambda is conforming
to if a method is overloaded with two or more versions with different functional interface parameters.
Interestingly Xtend does not have this restrictions and can figure out pretty well which overloaded version
of a method is called, based on inspection of the lambda passed to the method.<br>
Therefore the <code>CompletableFutureExtensions</code> class provides <code>then</code> methods simply redirecting to the
JDK methods.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.concurrent.CompletableFuture
import java.util.concurrent.Executors
// ...
val pool = Executors.newSingleThreadExecutor
val fut = CompletableFuture.supplyAsync([
	new Random().nextInt(1000)
],pool).then [ // thenApply, since has input and output value
	it / 10.0
].then [ // thenAccept, since has input, but expression does not return value
	System.out.println(&apos;&apos;&apos;Random percent: &#xAB;it&#xBB;&apos;&apos;&apos;)
].then [| // thenRun, since lambda does not take input
	System.out.println(&quot;The end.&quot;)
]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You may have noticed that the syntax for spawning a supplier via CompletableFuture#supplyAsync on a
custom executor does not look elegant, since the pool parameter is the last one. So the lambda cannot be
written behind the closing parenthesis of the parameter list. Have a look at the section <a href="14_async_computations.html">Async Computations</a>
for a more Xtend style API.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Currently there there are no <code>thenAsync</code> versions of the <code>then</code> methods implemented, but they are
planned to be provided in the future.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The extension methods starting with <code>when</code> register a callback on a <code>CompletableFuture</code> which is invoked
when it is completed an in a certain state, depending on the method. The returned future will always be completed
with the original value (successfully or exceptionally), except if the callback throws an exception. In this case
the returned future will be completed exceptionally with the exception thrown by the callback. If the callback
is registered before completion of the future, the callback is invoked on the thread completing the future. If
the callback is registered after completion of the future, the callback is invoked on the thread registering
the callback. The async version of the <code>when</code> methods are always completed on the executor passed to the
method, or on the common <code>ForkJoinPool</code> for the async version which does not take an executor as argument.</p>
</div>
<div class="paragraph">
<p>The extension method <code>whenCancelled</code> allows registering a callback on a <code>CompletableFuture</code>. The callback is
invoked when the future was completed via cancellation.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.concurrent.CompletableFuture
import static extension de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions.*
// ...
val toCancel = new CompletableFuture
toCancel.whenCancelled [|
	println(&quot;I&apos;ve been canceled&quot;)
]
toCancel.cancel</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>whenException</code> registers a callback which is invoked when the future is completed exceptionally.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.concurrent.CompletableFuture
import static extension de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions.*
// ...
CompletableFuture.supplyAsync [
	throw new IllegalStateException
].whenException [
	println(&apos;&apos;&apos;failed with &#xAB;it.class&#xBB; and cause &#xAB;it.cause.class&#xBB;&apos;&apos;&apos;)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>recoverWith</code> extension method is similar to the <code>thenCompose</code> method, but for the exceptional case.
The registered callback of type <code>(Throwable)&#x21D2;CompletionStage&lt;? extends R&gt;</code> will be invoked if the future
the callback is registered on completes exceptionally. The callback will be called with the exception the
original future was completed with exceptionally. The future returned from the callback will be used to
complete the future returned from the <code>recoverWith</code> extension method. This means if the original future
completes successfully, the result will be used to complete the future returned from the <code>recoverWith</code>
method. Otherwise the result of the recovery callback will be forwarded to the overall result future
(no matter if the result is successful or exceptional).</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.concurrent.CompletableFuture
import static extension de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions.*
// ...
CompletableFuture.supplyAsync [
	throw new IllegalStateException(&quot;Boom!&quot;)
].recoverWith [
	if(it.cause instanceof IllegalStateException)
		CompletableFuture.supplyAsync [
			&quot;I was expecting you! Here is your asynchronous backup value.&quot;
		]
	else
		throw new IllegalArgumentException(&quot;Did not expect this!&quot;, it)
].thenAccept [
	println(it)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are also <code>recoverWithAsync</code> versions where the recovery callback will always be executed on a given
executor.</p>
</div>
<div class="paragraph">
<p>It may be useful to abort a computation and get a default value instead. This can be done using the
<code>handleCancellation</code> extension method and canceling the original future.<br>
The <code>handleCancellation</code> extension method is called with a supplier function which provides a result
value when the source future is cancelled. If the original future completes successfully, the returned
future will simply be completed with the same value. If the original future was cancelled (or completed
with a <code>java.util.concurrent.CancellationException</code>), the given callback is called. If the callback
completes successfully, the result will be set on the resulting future. If the callback throws an exception,
this exception will be set as exceptional result to the resulting future. If the original future was completed
exceptionally with a different exception, the same exception will be set as the exceptional result
to the returned future.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.concurrent.CompletableFuture
import static extension de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions.*
// ...
val lateVal = CompletableFuture.supplyAsync [
	// Do not do this at home!
	// We are blocking the common pool
	Thread.sleep(1000)
	&quot;here is some belated value.&quot;
]

lateVal.handleCancellation [
	&quot;Here is some default value.&quot;
].thenAccept [
	println(it)
]

// let&apos;s be impatient
lateVal.cancel</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>handleCancellationAsync</code> variant executes the given handler always on the a provided executor.</p>
</div>
<div class="paragraph">
<p>Sometimes it is needed to take the result of one <code>CompletableFuture</code> and forward the result to another
future. This can e.g. be needed when a function is handed a future to complete and gets the actual result
from a method returning a future. For cases like this the <code>forwardTo</code> extension method can be used.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.concurrent.CompletableFuture
import static extension de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions.*
// ...
def void completeWithResult(CompletableFuture&lt;String&gt; res, boolean heavy) {
	if(heavy){
		doSomeHeavyWork().forwardTo(res)
	} else {
		res.complete(&quot;Some light work&quot;)
	}
}

def CompletableFuture&lt;String&gt; doSomeHeavyWork() {
	CompletableFuture.supplyAsync [
		&quot;Did some heavy lifting&quot;
	]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When returning a <code>CompletableFuture</code> from a method it may make sense to not return the future itself,
but a copy, which will be completed</p>
</div>
<div class="paragraph">
<p>When returning a <code>CompletableFuture</code> from a method which is decoupled from one ore more internal
futures (e.g using the <code>copy</code> or <code>forwardTo</code> extension method) it may still make sense to forward
cancellation from the returned future to the futures used internally to abort sub-tasks.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import java.util.concurrent.CompletableFuture
import static extension de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions.*
// ...
def CompletableFuture&lt;String&gt; someCancellableComposition(Executor executor) {
	val result = new CompletableFuture&lt;String&gt;
	val CompletableFuture&lt;String&gt; firstStep = firstStep(executor)
	result.forwardCancellation(firstStep)
	firstStep.thenCompose [
		val secondStep = secondStep(executor,it)
		result.forwardCancellation(secondStep)
		secondStep
	].forwardTo(result)

	result
}

def CompletableFuture&lt;String&gt; firstStep(Executor executor) {
	val result = new CompletableFuture&lt;String&gt;
	executor.execute [|
		Thread.sleep(10) // evil!
		if(result.cancelled) {
			println(&quot;cancelled in first step&quot;)
		} else {
			result.complete(&quot;Some result&quot;)
		}
	]
	result
}

def CompletableFuture&lt;String&gt; secondStep(Executor executor, String input) {
	val result = new CompletableFuture&lt;String&gt;
	executor.execute [|
		if(result.cancelled) {
			println(&quot;cancelled in first step&quot;)
		} else {
			val output = input.toUpperCase
			result.complete(output)
		}
	]
	result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see in the example, the cancellation is forwarded to the two futures that are
composed to calculate the overall result. Yet the returned future cannot be used to
complete any internal future with a bogus result value.</p>
</div>
<div class="paragraph">
<p>The extension method <code>cancelOnTimeout</code> is canceling a given <code>CompletableFuture</code>
when a timeout occurs. Note that this method returns the same future that is passed in.
This method does not return a new future, consider the complex form of <code>orTimeout</code>
(see below) for this effect.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">CompletableFuture.supplyAsync [
	Thread.sleep(100) // Never actually do this!
	&quot;Wow, so late&quot;
].cancelOnTimeout(50, TimeUnit.MILLISECONDS)
.whenCancelled[|
	println(&quot;Oh no! It took too long.&quot;)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, a version of <code>cancelOnTimeout</code> is provided taking a <code>java.time.Duration</code> as parameter.</p>
</div>
<div class="paragraph">
<p>Sometimes blocking APIs have to be used, but a future based API should be provided to the user.
In this case it may be desirable that the user can cancel the future to interrupt the thread
performing a blocking operation. This is tricky when running the blocking operations
using a thread pool, since the thread should only be interrupted as long as the operation
associated with the future is running. To support this use case the <code>whenCancelledInterrupt</code>
method is provided.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val blockOpPool = Executors.newCachedThreadPool // pool for running blocking operations
/// ...
val sleepy = blockOpPool.asyncRun [ CompletableFuture&lt;?&gt; it | (1)
	it.whenCancelledInterrupt [|
		try {
			Thread.sleep(100) // perform blocking operation
		} catch (InterruptedException e) {
			println(&quot;Hey, I was cancelled&quot;)
		}
	]
]
// ...
sleepy.cancel // may interrupt Thread.sleep</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Here an extension method described in <a href="14_async_computations.html">Async Computations</a> is used.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following functions introduced in JDK 9 on <code>CompletableFuture</code> have been back-ported
in class <code>de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions</code> as extension methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html#orTimeout-long-java.util.concurrent.TimeUnit-" target="_blank">CompletableFuture&lt;T&gt; orTimeout&#x200B;(long timeout,TimeUnit unit)</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html#copy--" target="_blank">CompletableFuture&lt;T&gt; copy&#x200B;()</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note, there is also a overloaded version of <code>orTimeout</code> which allows more fine grained options on the behavior of
this method. Here is an example for the configuration options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val slowFut = CompletableFuture.supplyAsync [
	Thread.sleep(100) // Never actually do this!
	&quot;Phew, so late&quot;
]
val withTimeout = slowFut.orTimeout [
	backwardPropagateCancel = false // do not cancel slowFut if withTimeout is cancelled
	cancelOriginalOnTimeout = false // do not cancel slowFut on timeout
	exceptionProvider = [new TimeoutException] // exception used to complete withTimeout on timeout
	scheduler = new ScheduledThreadPoolExecutor(1) // scheduler used for timeout
	timeout = (50L -&gt; TimeUnit.MILLISECONDS) // time after which withTimeout is completed exceptionally
	tryShutdownScheduler = true // if true tries to shutdown the given scheduler when slowFut completes
]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/concurrent/CompletableFutureExtensions.html" target="_blank">CompletableFutureExtensions</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_async_computations">Async Computations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Starting asynchronous computations and providing the result via a <code>CompletableFuture</code> is
provided via the JDK methods <code>CompletableFuture#runAsync</code> and <code>CompletableFuture#suppyAsync</code>.</p>
</div>
<div class="paragraph">
<p>These methods have a few drawbacks. The first one is that in Xtend it is good practice to
place the callback function as the last parameter in a parameter list to allow for more
elegant and readable syntax, placing the lambda behind the closing parentheses. The JDK methods,
however, have overloaded versions placing a executor for operation executor as last parameter.</p>
</div>
<div class="paragraph">
<p>The other drawback is that these methods need a further concept to allow cancellation of an operation
from the caller side, e.g. when the user cancels an operation. This can e.g. be achieved via an
additional <code>java.util.concurrent.atomic.AtomicBoolean</code> which is passed to the operation.
This is unfortunate, since the <code>CompletableFuture</code> already knows the concept of cancellation.</p>
</div>
<div class="paragraph">
<p>This library provides the class <code>de.fhg.fokus.xtensions.concurrent.AsyncCompute</code> introducing
the methods <code>asyncRun</code> and <code>asyncSupply</code>. These methods allow asynchronous computations
like the JDK methods, but with a shuffled parameter list and passing the created <code>CompletableFuture</code>
into the operation to be computed asynchronously.</p>
</div>
<div class="paragraph">
<p>Example using JDK classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static java.util.concurrent.CompletableFuture.*
import java.util.concurrent.Executors
// ...
val ex = Executors.newCachedThreadPool
val isCancelled = new AtomicBoolean(false)
runAsync([
	if(isCancelled.get) {
		println(&quot;Oh no, I&apos;ve been cancelled&quot;)
	} else {
		println(&quot;I&apos;m fine&quot;)
	}
], ex)
isCancelled.set(true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Same example using <code>AsyncCompute</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.concurrent.AsyncCompute.*
import java.util.concurrent.Executors
// ...
val pool = Executors.newCachedThreadPool
val fut = pool.asyncRun [
	if(cancelled) {
		println(&quot;Oh no, I&apos;ve been cancelled&quot;)
	} else {
		println(&quot;I&apos;m fine&quot;)
	}
]
fut.cancel(false)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>asyncRun</code> and <code>asyncSupply</code> methods have variants defining a timeout. If the provided actions
do not complete in the defined timeout, the returned future will be completed with a <code>TimeoutException</code>.
The action should then check for completion of the future passed into it, instead of for cancellation.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">asyncSupply(10, TimeUnit.MILLISECONDS) [
	// some poor integration approximation
	val fx = [double x| x*x + 10 - (2*x)]
	var sum = 0.0d;
	for(i : 0..100_000) {

		// every now and then, check if we timed out
		if(i % 100 == 0) {
			if(done) {
				return 0.0d;
			}
		}
		// also using poor double accumulation
		sum += fx.apply(i as double)
	}
	sum
].whenComplete[result, error |
	if(error !== null) {
		println(&quot;Whoops, timeout&quot;)
	} else {
		println(&quot;result = &quot; + result)
	}
]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/concurrent/AsyncCompute.html" target="_blank">AsyncCompute</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_scheduling_util">Scheduling Util</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>de.fhg.fokus.xtensions.concurrent.SchedulingUtil</code> provides several static methods
and static extension methods to easily schedule action for deferred or repeated execution.<br>
All operations have overloaded variants taking a <code>java.util.concurrent.ScheduledExecutorService</code>
as the first parameter, so these methods can be used as extension methods.</p>
</div>
<div class="paragraph">
<p>To repeat an action with a given period of time (starting immediately) you can use one of the overloaded
versions of the <code>repeatEvery</code> method.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.concurrent.SchedulingUtil.*
import static extension de.fhg.fokus.xtensions.datetime.DurationExtensions.*
// ...
val hundredMs = 100.milliseconds
repeatEvery(hundredMs) [
	println(currentTimeMillis)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>To repeat an action with a given period, starting with a delay instead of immediately, an overloaded
version of the <code>repeatEvery</code> method can be used:</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.concurrent.SchedulingUtil.*
import java.util.concurrent.TimeUnit
// ...
repeatEvery(100, TimeUnit.MILLISECONDS).withInitialDelay(200) [
	println(&quot;Delayed start, repeated every 100 milis period&quot;)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the action will stop being repeatedly called if the action throws an exception or the future
returned by the <code>repeatEvery</code> method will be completed (e.g. by canceling it). This can either either
be done by the action itself (the future will be passed to the action as parameter), or from the outside.<br>
Since the future is both passed to the action and returned, this also allows the action to check e.g. for
cancellation from the outside and aborting the action early.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.concurrent.SchedulingUtil.*
import static extension de.fhg.fokus.xtensions.datetime.DurationExtensions.*
// ...
val hundredMs = 100.milliseconds
val fut = repeatEvery(hundredMs) [
	for(i : 0..Integer.MAX_VALUE) {
		if(cancelled) {
			println(&quot;I&apos;ve been cancelled at iteration &quot; + i)
			return
		}
	}
]
fut.cancel(false)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>delay</code> will defer the one-time execution of a given action by the given duration.
The delayed execution can be aborted before being started by completing the future returned by
the <code>delay</code> method.<br>
The future returned by the <code>delay</code> method is also passed as a parameter to the deferred action.
If the future is completed before the delay is expired, the action will not be executed. If the
action is performed, it can check during execution if the future is completed, e.g. to return
prematurely (abort the action early).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.concurrent.SchedulingUtil.*
import static extension de.fhg.fokus.xtensions.concurrent.CompletableFutureExtensions.*
// ...

val result = new CompletableFuture&lt;String&gt;
result.thenAccept [
	println(it)
]

Executors.newCachedThreadPool.submit [
	Thread.sleep(100)
	result.complete(&quot;late response&quot;)
]

delay(50.milliseconds) [
	&quot;default value&quot;
].forwardTo(result) (1)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This extension method is explained in <a href="13_completable_future.html">Extensions to CompletableFuture</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The method <code>waitFor</code> will create a <code>CompletableFuture</code> that will be completed successfully
with a <code>null</code> value when the given duration expires. An overloaded version of the <code>waitFor</code>
method allows a deferred execution of a given callback, similar to the <code>delay</code> method, but
the callback does not provide a return value. The returned future will be completed with a
<code>null</code> value after successful execution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.concurrent.SchedulingUtil.*
//...

val repeatingFut = repeatEvery(100, TimeUnit.MILLISECONDS).withInitialDelay(50) [
	println(&quot;Delayed start, repeated every 100 milis period&quot;)
]

waitFor(50.milliseconds) [
	repeatingFut.cancel(false)
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same effect as shown here can be achieved with the <code>cancelOnTimeout</code> extension method on CompletableFuture,
described in <a href="13_completable_future.html">Extensions to CompletableFuture</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/concurrent/SchedulingUtil.html" target="_blank">SchedulingUtil</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_primitives">Primitives</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>de.fhg.fokus.xtensions.primitives.Primitives</code> provides a bunch of static extension methods
that are aimed to help handling primitive values at the end of null-safe navigation chains.</p>
</div>
<div class="sect2">
<h3 id="_boxing_primitives">Boxing Primitives</h3>
<div class="paragraph">
<p>To box the primitive value of a property at the end of a null-safe call chain, the <code>Primitives</code>
class provides the <code>box</code> and <code>boxNum</code> extension functions. These are intended to be used on
a context object, that&#x2019;s primitive property should be boxed. The function passed to the box function
is used to retrieve the primitive property.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.primitives.Primitives.*
// ...
val person = loadPerson(&quot;Mike&quot;)
person?.address.boxNum[floor]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example the last expression evaluates to an <code>Integer</code> which is <code>null</code> if <code>person</code> or <code>address</code>
is <code>null</code>. Otherwise it will hold a boxed <code>Integer</code> wrapping the <code>int</code> value of the <code>floor</code> property of <code>address</code>.
These boxing functions can be used both directly or using null-safe navigation. Using <code>?.</code>, however will perform
unnecessary null-checks.</p>
</div>
<div class="paragraph">
<p>It makes sense to call <code>onNull</code> functions subsequent to the boxing functions as described in <a href="#Default%20Values%20on%20%3Ccode%3Enull%3C/code%3E%20Boxes">[Default Values on <code>null</code> Boxes]</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_testing_conditions_on_primitive_values">Testing Conditions on Primitive Values</h3>
<div class="paragraph">
<p>Boxed boolean values (e.g. produced by functions described in <a href="#_boxing_primitives">Boxing Primitives</a>) can be tested
directly with the <code>null</code>-aware extension methods <code>isTrue</code>, <code>isFalse</code>, <code>isNullOrTrue</code>, <code>isNullOrFalse</code>.
These functions have to be called directly, not with null-safe navigation.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.primitives.Primitives.*
// ...
val person = loadPerson(&quot;Mike&quot;)
person?.address.box[isValidated].isTrue</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example if <code>person</code> and <code>address</code> are not <code>null</code> the <code>box</code> function will
return the boxed boolean value of attribute <code>isValidated</code>, otherwise <code>null</code>. The
call to <code>isTrue</code> will then check if the the boxed integer is not <code>null</code> and wraps the
value <code>true</code>.</p>
</div>
<div class="paragraph">
<p>To test if un-boxed primitives at the end of null-safe navigation chain adhere to a certain condition,
one of the extension methods <code>isTrue</code>, <code>isFalse</code>, <code>isNullOrTrue</code>, or <code>isNullOrFalse</code> taking
a testing function can be used.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.primitives.Primitives.*
// ...
val person = loadPerson(&quot;Mike&quot;)
person?.address.isTrue[floor &gt; 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example expression will return <code>true</code> if <code>person</code> and address are not <code>null</code>
and the <code>floor</code> property of <code>address</code> greater than <code>3</code>, otherwise it will return <code>false</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conversion_to_optionals">Conversion to Optionals</h3>
<div class="paragraph">
<p>Similar to the <a href="#_boxing_primitives">Boxing Primitives</a> functions, the <code>optionalInt</code>, <code>optionalLong</code> and <code>optionalDouble</code>
functions are supposed to box a primitive value property of a context object into a primitve optional value.
These extension functions however never return <code>null</code> . They return an empty optional if the the given context object is <code>null</code>.
If the context object is not <code>null</code> the value returned by the given mapper function is wrapped into the returned optional.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.primitives.Primitives.*
// ...
val person = loadPerson(&quot;Mike&quot;)
val OptionalInt nameLen = person?.lastName.optionalInt[length]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>person</code> and <code>lastName</code> in this example are not <code>null</code> the optional <code>nameLen</code>
will wrap the length of the <code>lastName</code> string. Otherwise <code>nameLen</code> will reference an
empty optional.</p>
</div>
</div>
<div class="sect2">
<h3 id="_default_values_for_code_null_code_boxes">Default Values for <code>null</code> Boxes</h3>
<div class="paragraph">
<p>The <code>onNull</code> extension functions for boxed primitives check if a given reference to a boxed primitive value
and will compute a default value via a given supplier if the box reference is <code>null</code>, otherwise they return
the unboxed primitive value.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">import static extension de.fhg.fokus.xtensions.primitives.Primitives.*
// ...
val person = loadPerson(&quot;Mike&quot;)
person?.address.boxNum[floor].onNull[0]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example the <code>onNull</code> call will return <code>0</code> if the given boxed <code>Integer</code> is <code>null</code>,
otherwise it will unbox the wrapped <code>int</code> value and return it.
The behavior of the example expression is equivalent to the behavior of the expression <code>person?.address?.floor</code>
which will result in a compiler warning, due to an implicit return of <code>0</code> if the navigation chain before <code>floor</code>
evaluates to <code>null</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Related JavaDocs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javadoc.io/page/com.github.fraunhoferfokus.xtensions/de.fhg.fokus.xtensions/latest/de/fhg/fokus/xtensions/Primitives.html" target="_blank">Primitives</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../../CHANGES.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Changelog">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Provided Functionality (as Single Page)","level":"2.2","depth":1,"previous":{"title":"Changelog","level":"2.1","depth":1,"path":"CHANGES.adoc","ref":"CHANGES.adoc","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["asciidoc-include@0.1.9"],"pluginsConfig":{"asciidoc-include":{"syntax":"gitbook"},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"docs/functionality/XX_provided_functionality_one_page.adoc","mtime":"2019-04-03T15:26:34.519Z","type":"asciidoc"},"gitbook":{"version":"3.2.3","time":"2019-04-10T08:29:50.274Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

